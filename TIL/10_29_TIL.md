# 10월 29일 Entry Front-End 수업 내용 정리

## CRA
CRA란, Create React App의 약자로 **리액트를 사용하기 위해 기본적인 셋팅을 도와주는 명령어**를 뜻한다. 우선 리액트를 설치하기 위해선, 터미널을 열어야 한다.
`VS code` 기준, `Ctrl + 백팃`을 누르면 터미널이 열린다.
<br>
우선 리액트를 설치하기 전, 리액트를 설치하기 위해 필요한 `npm`을 설치할 것이다. 우선, npm을 설치하기 전 설치가 되어있는지 버전 확인부터 해야한다. npm 버전 확인 명령어는 아래와 같다.<br>
~~~
npm -v
~~~
만일 설치가 되어있다면 현재 npm의 버전이 띄워질 것이다. 만일 npm이 설치되어 있지 않다면 `node.js`를 설치하도록 하자. `node.js`를 설치하면 npm도 같이 설치가 된다. <br><br>
npm을 이용하여 무언가의 패키지를 설치하고 싶다면 아래와 같은 명령어를 사용하면 된다.<br>
~~~
npm install -g (패키지 명) //혹은
npm i -g (패키지 명)
~~~
<br>
명령어 `i`는 `install`의 약자이므로 전자를 사용하던 후자를 사용하던 큰 상관은 없다. `-g`는 global의 약자로, 전역 설치를 하겠다는 뜻이다. 자, 그러면 이 명령어를 이용해 리액트를 설치하려면 무슨 명령어를 사용해야 할까?<br>
~~~
npm install -g creat-react-app //혹은
npm i -g creat-react-app
~~~
이 명령어들을 사용한다면, 우리의 작업 환경에 리액트가 설치되게 된다.

## 라이브러리
과연 라이브러리란 무엇일까? 쉽게 설명하자면 라이브러리는 **부품 혹은 도구**와 같다. <br><br>
우리가 건물을 짓는다고 치자. 그렇다면 굉장히 많은 것들이 필요할 것이다. 건물을 짓기 전 건물 설계도가 필요할 것이고, 건물을 지을 재료(시멘트나 벽돌 등)가 필요할 것이며, 건물을 지을 환경, 도구 등이 필요할 것이다. 이 중 단 하나라도 빠지게 된다면 당신은 건물을 지을 수 없게 될 것이다. 라이브러리 얘기를 하자고 했는데, 갑자기 건물을 짓는 얘기가 왜 나올까? 그 이유는 앞서 말했듯 라이브러리가 **부품 혹은 도구**와 비슷한 개념이기 때문이다. 즉, 건물을 지을 때 라이브러리가 되는 것은 **건물의 재료, 지을 도구**가 된다는 것이다. <br><br>
그럼 이제 라이브러리의 정확한 개념을 알아보자. 라이브러리란 **단순 활용 가능한 도구들의 집합**이다. 코드를 작성하다 보면 여러 번 재사용 해야하는 코드가 작성될 때가 꽤 많이 있다. 이럴 때 우리는 어떻게 했던가? 바로 **함수**라는 기능을 사용하거나 **클래스**로 정의하여 여러 번 불러왔었다. 라이브러리도 같은 개념이다. **개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 취하고 있다.** <br><br>
라이브러리를 사용할 지 말지는 사용자의 선택에 따라 나뉜다. 즉, 사용할 수도 있고 사용하지 않을수도 있다. **굳이 라이브러리를 사용하지 않아도 된다는 소리**이다. 또한, 새로운 라이브러리를 제작한다 하더라도 **엄격한 규칙이 존재하지 않는다.** 본인이 어떻게 제작하느냐에 따라 알맞게 사용하면 된다. <br><br>
라이브러리는 전혀 먼 개념이 아니다. 만일 당신이 웹페이지를 만드는데, 페이지 상단 부분, 즉 헤더가 여러 번 사용되어 재사용하기 쉽게 css 파일을 따로 빼 둔 상태로 만들어 놨다면, **이 또한 라이브러리가 되는 셈이다.** 또한, 우리가 흔히 사용하는 `jQuery`역시 JavaScript의 유명한 라이브러리이다.

## 비동기
비동기란, **어떠한 동작이 끝나기 전에 또 다른 동작을 수행할 수 있게 하는 것**을 말한다. 비동기의 비교 예시로 대게 동기를 자주 설명한다. 비동기가 어떠한 동작이 끝나기 전에 또 다른 동작을 수행할 수 있게 하는 것이라면, 동기는 무엇일까? 비동기와는 반대로 **어떠한 동작이 끝나기 전에는 또 다른 동작을 수행할 수 없게 하는 것**을 동기라고 한다. <br><br>
그렇다면 예시를 하나 들어보자. A는 지금 휴대폰을 하고있다. A가 휴대폰을 하면서 길을 걷고, 사람들과 마주치면 인사를 한다. 이 모든 일은 A가 **휴대폰을 하고 있는 순간에** 일어난다. 이러한 것을 *비동기*라고 한다. <br>
만일, A가 지금 휴대폰을 하고 있는데 길을 걷지도 않고, 사람들과 인사하지도 않으며, 오직 핸드폰에만 집중해 어떠한 동작이라던지 생산적인 활동 등을 일체 못하는 상태를 *동기*라고 한다. <br> <br>
비동기적 언어의 대표적인 예시로는 `JavaScript`가 있다.

### Promise
`Promise` 는 자바스크립트 비동기 처리에 사용되는 객체이다. 자바스크립트 코드를 짜다보면 불편한 적이 한 두번이 아니었을 것이다. 자바스크립트를 입문한지 얼마 되지 않은 사람들은 자바스크립트가 비동기적으로 동작하기 때문에 불편을 겪은 적이 꽤 많을 것이다. 가령, 아래의 코드와 같은 상황 말이다. 
<br>
~~~
$.get('url 주소/products/1', function (response) {
  // ...
});
~~~
<br>
위의 코드는 `ajax` 통신을 통해 서버에게 *데이터 하나를 보내주세요!* 라고 요청을 한 후, 데이터를 받으면 받은 데이터를 기반으로 작업을 수행하는 코드이다. 하지만 실제 이러한 코드를 돌려보면 *데이터를 보내기도 전에 마치 데이터를 받은 것처럼 동작을 해 빈 페이지가 뜨거나 에러가 발생하는 경우가 생긴다.* 이유는 바로 자바스크립트가 비동기적으로 동작하기 때문이다. <br>
앞서 설명했듯, 비동기는 하나의 작업이 끝날 때까지 기다리지 않고 다른 작업을 수행하기 때문이다. 하지만 자바스크립트를 사용하면서도 *동기적인 부분을 만들어야 하는 필요성* 을 느낄 때가 종종 있을 것이다. 하지만 비동기적으로 동작하는 언어인 자바스크립트를 어떻게 동기적으로 만들어 사용할 것인가? 이 문제에 대한 답이 바로 `Promise` 이다. <br><br>
우리는 보통 이러한 상황을 해결하기 위해 **콜백 함수** 를 사용했다. 쉽게 설명하자면, `Promise` 는 **콜백 함수를 사용함으로써 만들어지는 문제** 를 해결하기 위해 만들어진 문법이다. 문법은 아래와 같다.<br>

~~~
  new Promise();  
~~~

`Promise` 에는 총 3가지의 상태가 있다. 이 3가지의 상태를 알아보며 `Promise` 에 대해 구체적으로 알아보도록 하자. <br><br>

1. 대기 상태
대기 상태는 말 그대로 대기 상태에 있는 상태를 말한다. 이게 무슨 말이냐 하면, 비동기 처리 로직이 아직 완료되지 않은 상태를 대기 상태라 일컫는다. <br>
위에서 설명했던 것처럼, `new Promise();` 메소드를 호출하면 Promise는 대기 상태가 된다. 호출만 하고 아직 아무 로직도 실행되지 않았기 때문에 대기 상태에 들어가는 것이다. 만일 Promise를 호출하여 동기적인 동작을 하려 한다면, 대기 상태에서 이미 **함수의 인자에 접근할 수 있는 상태** 가 된다.
<br>
2. 이행 상태
이행 상태는 비동기 처리가 완료되어 프로미스 결과 값을 반환해준 상태이다. 이행 상태를 다른 말로 하면 **완료 상태** 라고 말할수도 있다. 이 상태에서는 대기 상태에서 접근한 인자를 이용해 일련의 동작을 할 수 있으며, `then()` 을 이용하여 처리 결과 값을 받을 수 있다. 만일 프로미스 체인을 만들고 싶다면, `.then()` 를 연이어서 사용하면 된다.  <br>
3. 실패 상태
상태의 이름만 봐도 감이 잡히지 않는가? Promise의 동작이 실패했을 때의 상태를 일컫는 상태이다. 만일 동작이 실패하여 실패 상태에 접근을 했다면, 이행 상태와는 반대로 `catch()` 로 실패한 이유(실패 처리의 결과값)을 받을 수 있다. `then()` 으로도 실패 처리의 결과값을 받을 수 있지만, 왠만하면 `catch()` 로 실패 처리의 결과값을 받는 것이 좋다. <br>

### axios
axios란 HTTP로 통신을 하기 위한 클라이언트 라이브러리이다. 동적으로 데이터를 가져오기 위한 라이브러리라고도 설명할 수 있다. 쉽게 설명하자면, **HTTP 통신을 위한 Promise 기반 라이브러리** 라고 할 수 있다. axios의 사용 문법은 아래와 같다. <br>
~~~
const axios = require('axios');
~~~

물론 axios는 라이브러리이기 때문에, 사용하려면 리액트처럼 다운을 받은 후 사용해야 한다. 다운 방법은 아래와 같다. 터미널에서 실행하는 것은 기본 중의 기본이다. <br>
~~~
npm i axios //npm 사용
bower i axios //bower 사용
~~~

## 클래스
클래스는 쉽게 생각하면, **여러 함수, 기능들의 집합** 이다. ES6 이전에는 클래스의 기능이 없었기 때문에 자바스크립트의 기능을 활용하여 클래스의 기능을 구현하여 사용하였다. 실제로, `npm` 을 사용하여 `class` 로 검색을 하면 수많은 패키지들이 나온다. 이것만 보아도 이전 자바스크립트에서는 클래스의 기능을 따로 구현하여 사용하고 있었다는 사실을 알 수 있다. <br>
하지만 이번에 ES6에서 클래스의 기능이 새로 추가되었다. 따로 구현하고 패키지를 다운받아 사용하지 않아도 된다는 말이다. 우리는 이제 더욱 쉽게 클래스의 기능을 취급할 수 있게 되었다.  <br> <br>
그렇다면, 우리가 굳이 클래스의 기능을 사용하는 이유는 무엇일까? 바로 **객체 단위로 코드 그룹화 및 코드 재사용성을 사용하기 위함**  이다. 예시를 들자면, **다음 페이지로 넘어가는 버튼을 누를 때 사용되는 함수들(next, loding 등등)을 각각 구현하는 방법 대신 이 모든 함수들을 하나의 클래스로 묶는 상황** 이 되는 셈이다. 우리가 이러한 상황에서 클래스를 사용하게 된다면 코드의 중복을 막을 수 있을 뿐만아니라 코드의 재사용성을 높이고, 가독성이 높아지며 유지보수 또한 높일 수 있게 된다. 아래는 클래스를 정의하는 방법이다. <br>

~~~
class 클래스 명 {
  constructor(number, name) {
    this.number = 12;
    name = 'entry';
  }
};
~~~

> constructor는 클래스로 생성된 객체를 생성하고 초기화 해주는 역할을 담당하는 메소드이다. 한 클래스 내에서 단 하나의 constructor 메소드만을 가질 수 있으며, 부모 클래스의 constructor를 불러오기 위해 super 키워드를 사용할 수 있다.

## Sass
Sass는 Syntactically Awesome Style Sheets의 줄임말로, 해석하자면 **문법적으로 짱 멋진 스타일 시트** 가 된다. 쉽게 생각하면 Sass란 css의 상위 버전이라고 말할 수 있다. css를 좀 더 효율적으로 보기 좋게 사용하는 문법이다. Sass를 사용한다면 복잡한 작업을 쉽게 해주며 코드의 재활용성을 높여줄 뿐만아니라 코드의 가독성을 높여줘 유지보수에 도움을 준다. 또한 Sass는 오직 `class` 만을 사용한다. 이 외에 Sass에는 총 8가지의 특징이 있다. <br><br>

1. 변수 <br>
Sass는 변수를 지정해 활용할 수 있다. 변수로 사용 가능한 형태는 **숫자, 문자열, 폰트, 색상, null, list, map** 이 있다. 변수를 사용할 땐 `$` 를 사용한다. 단, 변수를 생성해도 **사용하지 않으면 컴파일된 css 파일에는 나타나지 않는다.** <br>
또한 변수의 범위가 있는데, 변수를 특정 선택자 안에서 선언하게 된다면 그 선택자 안에서만 접근이 가능하다. 특정 선택자 내부에서 전역 변수를 사용하고 싶으면 `!global` 플래그를 사용한다. <br>
2. 수학 연산자<br>
Sass에서는 특이하게도 수학 연산자를 사용할 수 있다. 지원되는 연산자는 `+, -, /, *, %, ==, !=` 이다. 다만, 주의할 점은 수학 연산자를 사용할 시 **단위가 통일** 되어야 한다. <br>
3. 내장 함수<br>
Sass에서는 여러 언어들이 다양한 기능의 함수를 제공하듯이 **내장 함수** 를 제공한다. 대표적인 예시로 그림자를 손쉽게 적용시켜 주는 `darken()` 함수가 있다. 이 외에도 Sass는 다양한 함수를 제공하고 있다. <br>
4. 중첩<br>
또한 Sass는 선언을 중첩해서 사용할 수 있다. <br>
~~~
//CSS
.main {
  width: 100%;
  height: 100px;
}

.main h1 {
  font-family: "나눔고딕";
}

//Sass

.main {
  width: 100%;
  height: 100px;
  h1 {
    font-family: "나눔고딕";
  }
}
~~~
<br>
만일 부모 선택자를 리퍼런스 하고 싶다면 `&` 문자를 사용하면 된다. <br>
5. 불러오기<br>
Sass는 불러오기, 즉 `import` 기능을 사용하여 특정 Sass파일을 불러올 수 있다. 
~~~
@import "main.sass"; //혹은
@import "main"; //확장자를 붙이지 않아도 된다.
~~~
<br>
만일 파일의 이름을 `_` 로 시작하게 된다면, **css파일로 컴파일 되지 않는다.** html 파일에서 불러 올 필요 없이 `import` 기능으로만 사용되는 파일같은 경우는 이 경우를 활용하자. 이러한 기능을 **partial 기능** 이라고 한다. <br>
6. 상속 <br>
불러오기 뿐만아니라 상속까지 가능하다. `@extent` 를 사용한다면, 특정 선택자를 상속받는 것이 가능하다. 만일 Placeholder 선택자인 `%`를 사용하게 된다면 상속은 할 수 있지만 Placeholder 선택자를 사용한 해당 선택자는 컴파일 되지 않는다. <br>
7. 믹스인 <br>
믹스인은 Sass의 가장 유용한 기능 중 하나이다. `@extent` 기능과 비슷하지만, 인수를 받을 수 있는 기능이다. 믹스인 기능을 사용할 땐 `@mixin` 을 사용하며, 이를 사용할 땐 `@include` 를 사용한다. <br>
8. 함수 <br>
여기서의 함수는 내장 함수가 아닌 **사용자가 직접 정의한 함수** 를 의미한다. 믹스인과 다른 점은 믹스인은 **style markup** 을 반환하지만 함수는 **return으로 값을 반환** 한다는 점이다. 함수 기능을 사용할 때는 `@function` 을 사용한다. 

